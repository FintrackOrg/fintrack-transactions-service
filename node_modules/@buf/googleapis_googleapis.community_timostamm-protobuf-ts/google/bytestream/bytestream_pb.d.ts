/* eslint-disable */
// @generated by protobuf-ts 2.8.2 with parameter output_javascript,optimize_code_size,long_type_string,add_pb_suffix,ts_nocheck,eslint_disable
// @generated from protobuf file "google/bytestream/bytestream.proto" (package "google.bytestream", syntax proto3)
// tslint:disable
// @ts-nocheck
//
// Copyright 2016 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Request object for ByteStream.Read.
 *
 * @generated from protobuf message google.bytestream.ReadRequest
 */
export interface ReadRequest {
    /**
     * The name of the resource to read.
     *
     * @generated from protobuf field: string resource_name = 1;
     */
    resourceName: string;
    /**
     * The offset for the first byte to return in the read, relative to the start
     * of the resource.
     *
     * A `read_offset` that is negative or greater than the size of the resource
     * will cause an `OUT_OF_RANGE` error.
     *
     * @generated from protobuf field: int64 read_offset = 2;
     */
    readOffset: string;
    /**
     * The maximum number of `data` bytes the server is allowed to return in the
     * sum of all `ReadResponse` messages. A `read_limit` of zero indicates that
     * there is no limit, and a negative `read_limit` will cause an error.
     *
     * If the stream returns fewer bytes than allowed by the `read_limit` and no
     * error occurred, the stream includes all data from the `read_offset` to the
     * end of the resource.
     *
     * @generated from protobuf field: int64 read_limit = 3;
     */
    readLimit: string;
}
/**
 * Response object for ByteStream.Read.
 *
 * @generated from protobuf message google.bytestream.ReadResponse
 */
export interface ReadResponse {
    /**
     * A portion of the data for the resource. The service **may** leave `data`
     * empty for any given `ReadResponse`. This enables the service to inform the
     * client that the request is still live while it is running an operation to
     * generate more data.
     *
     * @generated from protobuf field: bytes data = 10;
     */
    data: Uint8Array;
}
/**
 * Request object for ByteStream.Write.
 *
 * @generated from protobuf message google.bytestream.WriteRequest
 */
export interface WriteRequest {
    /**
     * The name of the resource to write. This **must** be set on the first
     * `WriteRequest` of each `Write()` action. If it is set on subsequent calls,
     * it **must** match the value of the first request.
     *
     * @generated from protobuf field: string resource_name = 1;
     */
    resourceName: string;
    /**
     * The offset from the beginning of the resource at which the data should be
     * written. It is required on all `WriteRequest`s.
     *
     * In the first `WriteRequest` of a `Write()` action, it indicates
     * the initial offset for the `Write()` call. The value **must** be equal to
     * the `committed_size` that a call to `QueryWriteStatus()` would return.
     *
     * On subsequent calls, this value **must** be set and **must** be equal to
     * the sum of the first `write_offset` and the sizes of all `data` bundles
     * sent previously on this stream.
     *
     * An incorrect value will cause an error.
     *
     * @generated from protobuf field: int64 write_offset = 2;
     */
    writeOffset: string;
    /**
     * If `true`, this indicates that the write is complete. Sending any
     * `WriteRequest`s subsequent to one in which `finish_write` is `true` will
     * cause an error.
     *
     * @generated from protobuf field: bool finish_write = 3;
     */
    finishWrite: boolean;
    /**
     * A portion of the data for the resource. The client **may** leave `data`
     * empty for any given `WriteRequest`. This enables the client to inform the
     * service that the request is still live while it is running an operation to
     * generate more data.
     *
     * @generated from protobuf field: bytes data = 10;
     */
    data: Uint8Array;
}
/**
 * Response object for ByteStream.Write.
 *
 * @generated from protobuf message google.bytestream.WriteResponse
 */
export interface WriteResponse {
    /**
     * The number of bytes that have been processed for the given resource.
     *
     * @generated from protobuf field: int64 committed_size = 1;
     */
    committedSize: string;
}
/**
 * Request object for ByteStream.QueryWriteStatus.
 *
 * @generated from protobuf message google.bytestream.QueryWriteStatusRequest
 */
export interface QueryWriteStatusRequest {
    /**
     * The name of the resource whose write status is being requested.
     *
     * @generated from protobuf field: string resource_name = 1;
     */
    resourceName: string;
}
/**
 * Response object for ByteStream.QueryWriteStatus.
 *
 * @generated from protobuf message google.bytestream.QueryWriteStatusResponse
 */
export interface QueryWriteStatusResponse {
    /**
     * The number of bytes that have been processed for the given resource.
     *
     * @generated from protobuf field: int64 committed_size = 1;
     */
    committedSize: string;
    /**
     * `complete` is `true` only if the client has sent a `WriteRequest` with
     * `finish_write` set to true, and the server has processed that request.
     *
     * @generated from protobuf field: bool complete = 2;
     */
    complete: boolean;
}
declare class ReadRequest$Type extends MessageType<ReadRequest> {
    constructor();
}
/**
 * @generated MessageType for protobuf message google.bytestream.ReadRequest
 */
export declare const ReadRequest: ReadRequest$Type;
declare class ReadResponse$Type extends MessageType<ReadResponse> {
    constructor();
}
/**
 * @generated MessageType for protobuf message google.bytestream.ReadResponse
 */
export declare const ReadResponse: ReadResponse$Type;
declare class WriteRequest$Type extends MessageType<WriteRequest> {
    constructor();
}
/**
 * @generated MessageType for protobuf message google.bytestream.WriteRequest
 */
export declare const WriteRequest: WriteRequest$Type;
declare class WriteResponse$Type extends MessageType<WriteResponse> {
    constructor();
}
/**
 * @generated MessageType for protobuf message google.bytestream.WriteResponse
 */
export declare const WriteResponse: WriteResponse$Type;
declare class QueryWriteStatusRequest$Type extends MessageType<QueryWriteStatusRequest> {
    constructor();
}
/**
 * @generated MessageType for protobuf message google.bytestream.QueryWriteStatusRequest
 */
export declare const QueryWriteStatusRequest: QueryWriteStatusRequest$Type;
declare class QueryWriteStatusResponse$Type extends MessageType<QueryWriteStatusResponse> {
    constructor();
}
/**
 * @generated MessageType for protobuf message google.bytestream.QueryWriteStatusResponse
 */
export declare const QueryWriteStatusResponse: QueryWriteStatusResponse$Type;
/**
 * @generated ServiceType for protobuf service google.bytestream.ByteStream
 */
export declare const ByteStream: any;
export {};
